require('dotenv').config();


const TelegramBot = require("node-telegram-bot-api");
const token = process.env.TELEGRAM_TOKEN;
const bot = new TelegramBot(token, {polling: true});

const Role = Object.freeze({
    THINKER: "thinker",
    CONTACTOR: "contactor",
    NONE: null
});

const defaultGameState = {
    active: false,
    word: "",
    firstLetter: "",
    revealedLetters: "",
    thinker: null,
    contactWordMap: new Map(),
    contactorsTimer: null,
    currentContactId: 1,
    activeContactId: null,
    thinkerTimer: null
    //contact id, users array
    // contactUsersMap: new Map(),
};
//chatid, gameid
const chatGameMap = new Map()

//userid, chatid-- it is map because user can only play in one game simultaneously
const userChatMap = new Map()
// role can be contacter, thinker or null
const userRoleMap = new Map()

// commands
bot.setMyCommands([
    {command: '/start_bot', description: '–ü–æ—á–∞—Ç–∏ –≥—Ä—É'},
    {command: '/start_game', description: '–ü–æ—á–∞—Ç–∏ –≥—Ä—É'},
    {command: '/zahadaty', description: '–ó–∞–≥–∞–¥–∞—Ç–∏ —Å–ª–æ–≤–æ'},
    {command: '/rules', description: '–ü—Ä–∞–≤–∏–ª–∞'},
    {command: '/game', description: '–ò–≥—Ä–∞ —É–≥–∞–¥–∞–π —Ü–∏—Ñ—Ä—É'},
])

function clearGameState(chatId) {
    let gameState = deepCopyDefaultState()
    chatGameMap.set(chatId, gameState);
}

function deepCopyDefaultState() {
    return structuredClone(defaultGameState)
}

async function thinkerMakesWord(gameState, messageText, userId, groupChatId) {
    if (gameState.word !== "") return
    gameState.word = messageText.toLowerCase();
    gameState.firstLetter = gameState.word[0].toUpperCase();
    gameState.revealedLetters = gameState.firstLetter;
    chatGameMap.set(groupChatId, gameState);

    await bot.sendMessage(userId, "‚úÖ –°–ª–æ–≤–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ! –ü–æ–≤—ñ–¥–æ–º –¥—Ä—É–∑—ñ–≤, —â–æ –≥—Ä–∞ –ø–æ—á–∞–ª–∞—Å—å.");
    await bot.sendMessage(groupChatId, `–ü–µ—Ä—à–∞ –±—É–∫–≤–∞: *${gameState.firstLetter}*. –í–í–µ–¥–∏ –∫–æ–º–∞–Ω–¥—É 
    /contact –ø–æ—è—Å–Ω–µ–Ω–Ω—è —Å–ª–æ–≤–∞, —â–æ–± —ñ–Ω—à—ñ –º–æ–≥–ª–∏ —Å–∫–æ–Ω—Ç–∞–∫—Ç—É–≤–∞—Ç–∏ –∑ —Ç–æ–±–æ—é `, {parse_mode: "Markdown"});

}

function setRoles(userIds, role) {
    for (let userId in userIds)
        userRoleMap.set(userId, role);
}

async function contacterWritesWord(gameState, messageText, userId, groupChatId) {
    if (!gameState.contactWordMap.has(userId)) return;
    if (gameState.contactWordMap.get(userId) !== null) return
    gameState.contactWordMap.set(userId, messageText.toLowerCase());
    await bot.sendMessage(userId, "–°–ª–æ–≤–æ –∑–∞—Ñ—ñ–∫—Å–æ–≤–∞–Ω–æ! –¢–µ–ø–µ—Ä –ø–æ–±–∞—á–∏–º–æ —á–∏ —É –≤–∞—Å —Å—Ç–∞–≤—Å—è –∑–±—ñ–≥ ...");
    gameState.amountOfReadyContacters += 1;
    if (gameState.amountOfReadyContacters === 2) {
        console.log("input value array", Array.from(gameState.contactWordMap.values()))
        const isCorrect = checkContactCorrectness(gameState.revealedLetters, Array.from(gameState.contactWordMap.values()))
        if (isCorrect) {
            gameState.revealedLetters = gameState.word.substring(0, gameState.revealedLetters.length + 1);
            await bot.sendMessage(groupChatId, `üìù –ù–æ–≤–∞ –±—É–∫–≤–∞: *${gameState.revealedLetters}*`, {parse_mode: "Markdown"});
        }
        if (gameState.revealedLetters.length === gameState.word.length) {
            await bot.sendMessage(groupChatId, "üéâ –í—ñ—Ç–∞—î–º–æ! –°–ª–æ–≤–æ –≤—ñ–¥–≥–∞–¥–∞–Ω–µ! –ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.");
            clearGameState(groupChatId);
        }
        if (!isCorrect) {
            await bot.sendMessage(groupChatId, "–ù–∞ –∂–∞–ª—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ –≤–≤–µ–ª–∏ —Ä—ñ–∑–Ω—ñ —Å–ª–æ–≤–∞(. –ù–æ–≤–∞ –±—É–∫–≤–∞ –Ω–µ –±—É–¥–µ –≤—ñ–¥–∫—Ä–∏—Ç–∞");
        }
        clearContact(gameState);
        setRoles(Array.from(gameState.contactWordMap.keys()), Role.NONE)
    }
    chatGameMap.set(groupChatId, gameState);
}

async function registerContact(gameState, userId, chatId, message) {
    let activeContactUsers;
    for (let [contactId, userIds] of gameState.contactUsersMap) {
        // –¥–æ–¥–∞—Ç–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –Ω–∞ —Ç–µ, —â–æ–± –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —â–µ —Ç–∞–º –Ω–µ –±—É–ª–æ)
        if (!message.reply_to_message.from) continue
        if (userIds.includes(message.reply_to_message.from.id)) {
            gameState.activeContactId = contactId;
            userIds.push(userId);
            gameState.contactUsersMap.set(contactId, userIds)
            activeContactUsers = userIds
            await bot.sendMessage(chatId, `–Ñ –∫–æ–Ω—Ç–∞–∫—Ç`);
            userChatMap.set(userId, chatId);
        }
    }
    return activeContactUsers;
}

async function initiateContact(gameState, userId, chatId) {
    gameState.currentContactId++;
    gameState.contactUsersMap.set(gameState.currentContactId, [userId]);
    await bot.sendMessage(chatId, "–ß–µ–∫–∞–π –ø–æ–∫–∏ —Ö—Ç–æ—Å—å –∑ —Ç–æ–±–æ—é —Å–∫–æ–Ω—Ç–∞–∫—Ç—É—î! (–≤–≤–µ–¥–µ –∫–æ–º–∞–Ω–¥—É /contact)");
    chatGameMap.set(chatId, gameState);
    userChatMap.set(userId, chatId);
}

async function notifyContacters(gameState, activeContactUsers, chatId) {
    let notified = true
    gameState.contactWordMap.set(activeContactUsers[0], null);
    gameState.contactWordMap.set(activeContactUsers[1], null);
    console.log("Active contacts", activeContactUsers[0], activeContactUsers[1])
    let keys = Array.from(gameState.contactWordMap.keys());
    let usernames = getUsernamesByIDs(chatId, keys);
    await bot.sendMessage(chatId, `${usernames[0]} i ${usernames[0]} - —É –≤–∞—Å –∫–æ–Ω—Ç–∞–∫—Ç!. –ü–∏—à—ñ—Ç—å —Å–ª–æ–≤–æ –º–µ–Ω—ñ –≤ –æ—Å–æ–±–∏—Å—Ç—ñ)`);
    try {
        await bot.sendMessage(keys[0], `–Ø —Ç—É—Ç! –ü–∏—à–∏ —Å–ª–æ–≤–æ`);
        await bot.sendMessage(keys[1], `–Ø —Ç—É—Ç! –ü–∏—à–∏ —Å–ª–æ–≤–æ`);
        clearContact(chatId, activeContactUsers)
    } catch (e) {
        notified = false;
        await bot.sendMessage(chatId, `${usernames[0]} i ${usernames[0]} - –≤–∏ –æ–±–∏–¥–≤–∞ –º–∞—î—Ç–µ —ñ–Ω—ñ—Ü—ñ—é–≤–∞—Ç–∏ –∫–æ–Ω—Ç–∞–∫—Ç –∑ –±–æ—Ç–æ–º, —â–æ–± –≥—Ä–∞—Ç–∏!
        –ö–æ–Ω—Ç–∞–∫—Ç —Å–∫–∞—Å–æ–≤–∞–Ω–æ!`);
        clearContact(chatId, activeContactUsers);
    }
    return notified;
}

async function setTimerForContacters(chatId, gameState) {
    await bot.sendMessage(chatId, "üïê –í—ñ–¥–ª—ñ–∫: 5... 4... 3... 2... 1...");
    gameState.timer = setTimeout(() => {
        bot.sendMessage(chatId, "‚åõ –ß–∞—Å –≤–∏–π—à–æ–≤... –ù–µ –≤—Å—ñ –∫–æ–Ω—Ç–∞–∫—Ç–∏ –Ω–∞–ø–∏—Å–∞–ª–∏ —Å–ª–æ–≤–æ ..");
        clearContact(chatId)
    }, 5000);
}

async function contact(gameState, message, chatId) {
    const userId = message.from.id;
    if (!gameState || !gameState.active || !message.text) {
        await bot.sendMessage(chatId, "–ì—Ä–∞ —â–µ –Ω–µ –ø–æ—á–∞–ª–∞—Å—å! –ù–∞—Ç–∏—Å–Ω–∏ /start_game ");
        return;
    }
    if (gameState.activeContactId != null) {
        await bot.sendMessage(chatId, "2 —ñ–Ω—à—ñ –ª—é–¥–∏–Ω–∏ –≤–∂–µ –∫–æ–Ω—Ç–∞–∫—Ç—É—é—Ç—å! –ó–∞—á–µ–∫–∞–π —Å–≤–æ—î—ó —á–µ—Ä–≥–∏)");
        return;
    }
    // –ó–∞–∫–æ–º–µ–Ω—Ç–æ–≤–∞–Ω–æ –≤ —Ü—ñ–ª—è—Ö —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è
    // if (userId === gameState.thinker) {
    //     await bot.sendMessage(chatId, "–ó–∞–≥–∞–¥—É–≤–∞—á –Ω–µ –º–æ–∂–µ –±—Ä–∞—Ç–∏ —É—á–∞—Å—Ç—å —É –∫–æ–Ω—Ç–∞–∫—Ç—ñ");
    //     return;
    // }

    let activeContactUsers = await registerContact(gameState, userId, chatId, message);
    console.log("activeContactId", gameState.activeContactId)
    if (!gameState.activeContactId) {
        return await initiateContact(gameState, userId, chatId);
    }

    const notified = await notifyContacters(gameState, activeContactUsers, chatId);
    if (notified) {
        await setTimerForContacters(chatId, gameState)
        gameState.thinkerTimer = setTimeout(async () => {
            await bot.sendMessage(chatId, "‚ùå –ó–∞–≥–∞–¥—É–≤–∞—á –Ω–µ –Ω–∞–ø–∏—Å–∞–≤ —Å–ª–æ–≤–æ!")
            gameState.revealedLetters = gameState.word.substring(0, gameState.revealedLetters.length + 1);
            await bot.sendMessage(chatId, `üìù –ù–æ–≤–∞ –±—É–∫–≤–∞: *${gameState.revealedLetters}*`, {parse_mode: "Markdown"});
        }, 5000)
    }
    chatGameMap.set(chatId, gameState);
}

async function startGame(gameState, chatId) {
    if (!gameState) {
        chatGameMap.set(chatId, deepCopyDefaultState())
        gameState = chatGameMap.get(chatId);
    }
    if (gameState.active) return bot.sendMessage(chatId, "–ì—Ä–∞ –≤–∂–µ –π–¥–µ!");
    clearGameState(chatId);
    gameState.active = true;
    chatGameMap.set(chatId, gameState);
    return bot.sendMessage(chatId, "üîÆ –•—Ç–æ –∑–∞–≥–∞–¥–∞—î —Å–ª–æ–≤–æ? –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å /zahadaty");

}

async function newWord(gameState, chatId, userId) {
    if (!gameState.active) return bot.sendMessage(chatId, "–ì—Ä–∞ —â–µ –Ω–µ –ø–æ—á–∞–ª–∞—Å—å! –ù–∞—Ç–∏—Å–Ω–∏ /start_game");
    if (gameState.thinker) return bot.sendMessage(chatId, "–ó–∞–≥–∞–¥—É–≤–∞—á –≤–∂–µ –≤–∏–±—Ä–∞–Ω–∏–π!");
    gameState.thinker = userId;
    chatGameMap.set(chatId, gameState);
    try {
        await bot.sendMessage(userId, "ü§´ –í–≤–µ–¥–∏ —Å–ª–æ–≤–æ, —è–∫–µ —Ç—Ä–µ–±–∞ –∑–∞–≥–∞–¥–∞—Ç–∏. (–¶–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –æ—Å–æ–±–∏—Å—Ç–æ–º—É —á–∞—Ç—ñ)");
    } catch (error) {
        await bot.sendMessage(chatId, "ü§´ –ó–ê–ô–î–ò –í –ë–û–¢–ê –ò –ù–ê–ñ–ú–ò–ò –°–¢–ê–†–¢–ë–û–¢, –¢–û–ì–î–ê –ó–ê–ì–ê–î–ï–®–¨");
    }
}

async function thinkerBeatContact(gameState, messageText, chatId, groupChatId) {
    return Promise.resolve(undefined);
}

bot.on('message', async message => {
        const isPrivate = (message.chat.type === "private");
        const userId = message.from.id
        const chatId = message.chat.id
        let gameState = chatGameMap.get(chatId);
        let messageText = message.text;
        //–ø—Ä–∏–≤–∞—Ç–Ω–∏–π —á–∞—Ç
        if (isPrivate) {
            if (messageText === "/start_bot") {
                return await bot.sendMessage(chatId, "–¢–µ–ø–µ—Ä —Ç–∏ –º–æ–∂–µ—à –±—Ä–∞—Ç–∏ —É—á–∞—Å—Ç—å –≤ —ñ–≥—Ä–∞—Ö")
            }
            if (!gameState || !gameState.active) return;
            const groupChatId = userChatMap.get(userId);
            const role = userRoleMap.get(userId);
            if (role === Role.THINKER) {
                if (gameState.thinkerTimer) return await thinkerBeatContact(gameState, messageText, chatId, groupChatId)
                return await thinkerMakesWord(gameState, messageText, userId, groupChatId)
            }
            if (role === Role.CONTACTOR) {
                return await contacterWritesWord(gameState, messageText, userId, groupChatId)
            }
            return
        }

        //—á–∞—Ç –ø—É–±–ª—ñ—á–Ω–∏–π
        if (messageText === "/start_game") {
            return await startGame(gameState, chatId)
        }
        if (messageText === "/zahadaty") {
            return await newWord(gameState, chatId, userId)
        }
        const contactCommandRegExp = "^\\/contact(?:\\s+.+)?$"
        if (contactCommandRegExp.test(messageText)) {
            return await contact(gameState, message, chatId)
        }

    }
)


function clearContact(chatId, contacterIds) {
    let gameState = chatGameMap.get(chatId);
    clearTimeout(gameState.timer)
    gameState.timer = null;
    gameState.contactUsersMap.delete(gameState.activeContactId);
    gameState.activeContactId = null;
    gameState.contactWordMap.clear();
    chatGameMap.set(chatId, gameState);
    setRoles(contacterIds, Role.NONE)
}

function getChatIdByThinker(userId) {
    for (let [gameId, gameState] of chatGameMap) {
        if (gameState.thinker === userId) {
            return gameId;
        }
    }
    return null;
}

function getUsernamesByIDs(chatId, ids) {
    try {
        let usernames = []
        console.log("ids getUsernamesByIDs", ids)
        for (let userId in ids) {
            bot.getChatMember(chatId, userId)
                .then(chatMember => {
                    console.log("chat member", chatMember);
                    const username = chatMember.user.username;
                    usernames.push(username);
                });
        }
        return usernames;
    } catch (e) {
        console.log("getUsernamesByIDs misfunction")
    }
}

bot.on("message", async (message) => {

    const isPrivate = (message.chat.type === "private");
    if (isPrivate) return;
    const chatId = message.chat.id;
    let gameState = chatGameMap.get(chatId);
    if (!gameState) return;
    const userId = message.from.id;
    if (userId !== gameState.thinker) return;
    if (!gameState.active || !message.text) return;
    if (!gameState.contactWordMap) return;
    const contactWords = Array.from(gameState.contactWordMap.values());
    if (gameState.timer !== null && (message.text === contactWords[0] || message.text === contactWords[1])) {
        clearContact(chatId);
        gameState.contactUsersMap.delete(gameState.activeContactId);
        await bot.sendMessage(chatId, "‚ùå –ó–∞–≥–∞–¥—É–≤–∞—á –ø–µ—Ä–µ–±–∏–≤ –≤—ñ–¥–≥–∞–¥—É–≤–∞–Ω–Ω—è! –ù–æ–≤–∞ –±—É–∫–≤–∞ –Ω–µ –±—É–¥–µ –¥–æ–¥–∞–Ω–∞.");
    }
    chatGameMap.set(chatId, gameState);

})

function checkContactCorrectness(contactWords, revealedLetters) {
    if (!contactWords[0] === contactWords[1]) return false;
    if (!contactWords[0].startsWith(revealedLetters.toLowerCase())) return false;
    return true;
}

bot.on("message", async (message) => {
    const isPrivate = (message.chat.type === "private");
    if (isPrivate) return;
    const chatId = message.chat.id;
    let gameState = chatGameMap.get(chatId);
    if (!gameState) return;
    if (!gameState.active || !message.text) return;
    if (message.text === gameState.word) {
        await bot.sendMessage(chatId, "üéâ –í—ñ—Ç–∞—î–º–æ! –°–ª–æ–≤–æ –≤—ñ–¥–≥–∞–¥–∞–Ω–µ! –ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.");
        clearGameState(chatId);
    }

})
